---
title: 跨域解决
author: 苏永蓬
authorLink: https://github.com/EffortRocks
excerpt: 本文简单介绍了会发生跨域的情况并给出了相应的解决办法
thumbnail: 2020/08/27/跨域解决/title.jpg
categories:
  - [安全]
    - [跨域]
tags:
  - CORS
toc: true
date: 2020-08-27 17:59:00
updated: 2020-08-27 17:59:00
---
# 跨域解决

## 一、什么导致了跨域
## 1.1 跨域
首先，网络是没有绝对安全可言的，但是，我们又需要使用浏览器来访问网络，所以浏览器能存在的安全基础就是有相对较高的安全性，提升了别人做坏事的成本。

[CORS(同源策略)](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)就是浏览器安全的一个重要部分。  

同源策略是一个重要的安全策略，它用于限制一个[源](https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90)的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 

同源策略的目的有两个：
  + **对外：保证用户信息的安全，防止恶意的网站窃取数据**。
  + **对内：约束网站使用的资源尽可能是同源可控，来增强网站的安全性**。  

真实案例（仅限演示例子使用）：  
在登录腾讯文档后，打开一个文档，在控制台调用下面的代码，将会给一个好友分配该文档的编辑权限。
```javascript
  $.ajax({
    type: "post",
    url: 'https://docs.qq.com/cgi-bin/redirect/300000000/ep/api/setpadinfo?localPadId=BYtWkVVnlVCW&type=1&ver=2&route_ip=&room_route_ip=&get_vip_info=1',
    data: 'corp_id=&data=%7B%22policy%22%3A1%2C%22addmemlist%22%3A%5B%7B%22uintype%22%3A0%2C%22uin%22%3A2803621806%2C%22work_id%22%3A%22%22%2C%22info%22%3A2%2C%22new%22%3A1%7D%5D%2C%22submemlist%22%3A%5B%5D%7D&message=%7B%22seq%22%3A%2272bcde05-6052-44f2-be8c-b6454a3e6716%22%2C%22action%22%3A1%7D&xsrf=ac8bd23b7c50fa4b&dataType=0',
    success: function(data) {
      console.log(data);
    },
    error: function(err) {}
  });
```
退出账号后，调用相同代码，不能给相同好友分配该文档的编辑权限。并报下面的错误。
```javascript
cgicode: 11000
msg: "no correct p_uin or p_skey or uid or uid_key in cookie [errcode:11000:0]"
retcode: 11000
```
由报错可以看出，出现问题是因为cookie中缺少相关信息，导致服务端认证失败。

在其他网站的控制台调用相同代码会报如下错误：
```javascript
Access to XMLHttpRequest at 'https://docs.qq.com/cgi-bin/redirect/300000000/ep/api/setpadinfo?localPadId=BYtWkVVnlVCW&type=1&ver=2&route_ip=&room_route_ip=&get_vip_info=1' from origin 'https://fanyi.baidu.com' has been blocked by CORS policy: 、No 'Access-Control-Allow-Origin' header is present on the requested resource.
```
现在根据上面的情况试想在没有同源策略的情况下：  
在你登陆腾讯文档后，再打开一个其他源的网站，调用上面的代码，也是会成功给好友分配编辑权限的。进而联想到在一个第三方网站掌握腾讯文档的接口信息规则后，就可以假冒你对你的账号进行任意操作，这是十分可怕的。  

那么怎么判断是同一个源呢，它的定义是什么呢？ 

同源的定义：  
如果两个 URL的[协议](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、[主机](https://developer.mozilla.org/en-US/docs/Glossary/host) 和 [端口](https://developer.mozilla.org/en-US/docs/Glossary/port) (如果有指定的话) 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”。

注：
1. 只有**浏览器才会有跨域问题**。
2. 恶意文档：可能导致推栈缓冲区溢出，从而在电脑中执行一些代码的文件，一般指病毒或者木马的运行程序。

## 1.2 跨域示例
下表给出了与 URL：http://store.company.com/dir/page.html 的源进行对比的示例:
|  URL  | 结果  |  原因  |
|  --  | -- |  --  |
|  http://store.company.com/dir2/other.html  | 同源  |  只有路径不同  |
|  http://store.company.com/dir/inner/another.html  | 同源  |  只有路径不同  |
|  https://store.company.com/secure.html  | 失败  |  协议不同  |
|  http://store.company.com:81/dir/etc.html  | 失败  |  端口不同 ( http: 默认端口是80;https: 默认端口是443)  |
|  http://news.company.com/dir/other.html  | 失败  |  主机不同  |
注：**域名和IP指向一样，但是还是会引起跨域的。**
## 1.3 限制范围
随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有四种行为受到限制。
+ Cookie、LocalStorage、SessionStorage 和 [IndexDB](http://www.ruanyifeng.com/blog/2018/07/indexeddb.html) 无法读取。
+ DOM 无法获得。
+ 方法不能调用
+ AJAX 请求不能发送。
# 二、常见跨域错误
## 1. 缺少可跨域响应头
{% asset_img err-CORS1.png %}
    
关键字： **No 'Access-Control-Allow-Origin' header**
## 2. 允许跨域的值重复
{% asset_img err-CORS2.png %}

关键字： **The 'Access-Control-Allow-Origin' header contains multiple values '\*, \*', but only one is allowed**。  
原因： **多次代理的时候配置的允许跨域的值有重复的**。
## 3. 不允许访问其他域的对象或者存储数据
{% asset_img err-CORS3.png %}

关键字：**block a frame with origin  form accessing a cross-origin frame**

# 三、解决跨域
# 1. 跨域网络访问（Cross-origin network access）
因为跨域产生的原因是两个资源不在同一个域，所以有四种解决的办法：  
+ 把两个资源放到同一个域中
+ 服务器允许资源是可以跨域共享([CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html)) 
+ 浏览器插件
+ 利用一些不受同源策略影响的标签实现（``script``）

### 1) 把两个资源放到同一个域中
+ [反向代理](https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488?fr=aladdin)：通过 **nginx** 把多个资源代理到一块
	- 参考 **[nginx说明文档](https://docs.qq.com/doc/DSlh5YVJEbUhiV1dI)**  
注： 在能操作文件的情况下，不建议**多次代理**，因为这样会导致**网络传输变慢**，影响系统的流畅性。
+ [正向代理](https://baike.baidu.com/item/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86)：通过同域的接口返回其他域的资源  

注：
  + 反向代理：访问自定义的接口来返回其他接口的资源，通过自定义接口已经**不能分出真实资源来自哪里**。
  + 正向代理：由代理服务器去请求资源并返回给你，**访问还是原来的真实网址**。
  + 不管是正向代理还是反向代理，都是由服务器端去进行访问的，所以**要保证在服务器端能访问到真实地址**。


### 2) 服务器允许资源是可以跨域共享  
* Tomcat  

在 Tomcat根目录 --> conf --> web.xml 的 ``web-app`` 节点下加入如下代码。
```xml
<filter>
	<filter-name>CorsFilter</filter-name>
	<filter-class>org.apache.catalina.filters.CorsFilter</filter-class>
	<init-param>
		<param-name>cors.allowed.origins</param-name>
		<param-value>*</param-value>
    <!-- 当指定部分可跨域时，使用下面代码配置指定域 -->
    <!-- <param-value>http://127.0.0.1</param-value> -->
	</init-param>
</filter>
<filter-mapping>
	<filter-name>CorsFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
```
  注: **Tomcat配置修改后必须重启Tomcat才会生效**。
* Nginx  
在 Nginx的根目录 --> conf --> nginx.conf 文件适当写入下述代码。
	+ 全局可跨域
	```python
	# 在 server 节点下添加以下语句
	add_header Access-Control-Allow-Origin *;
	add_header 'Access-Control-Allow-Credentials' 'true';
	add_header Access-Control-Allow-Methods 'GET,POST';
	add_header Access-Control-Allow-Headers 'Content-Type,*';
	```
	+ 指定接口可跨域
	```python
	# 在指定的 location 节点下添加，示例如下：
	location /tomcat/ {
		proxy_pass   http://localhost:8090/;
		add_header Access-Control-Allow-Origin *;
		add_header 'Access-Control-Allow-Credentials' 'true';
		add_header Access-Control-Allow-Methods 'GET,POST';
		add_header Access-Control-Allow-Headers 'Content-Type,*';
	}
	```
	注：
  + Nginx配置修改后必须**重启**才会生效。
  + 同时添加全局可跨域和指定接口可跨域时，访问指定接口会产生可跨域响应头重复的问题，可使用指定接口代理，因此推荐**不使用全局可跨域**。
  + 注意``localtion``的匹配规则
  + 当配置指定域可跨域时，可把``*``换为**具体的域名或者IP**，多个之间用**逗号**隔开。

  补：**location和proxy_pass易混淆点**
  + [location](https://segmentfault.com/a/1190000013267839) (后面两点为URL访问的相关知识补充)
    - ``location`` 后面带不带`` /`` 都是一样的

    - 如果URL的格式为``http://my.suyp.com/``或者``http://127.0.0.1:10229/``，**尾部有没有``/``都不会造成[重定向](https://baike.baidu.com/item/%E9%87%8D%E5%AE%9A%E5%90%91/9064196?fr=aladdin)**。  
      因为这种情况下，浏览器请求时会在后面默认加上``/``。可以这样理解，没有请求是访问的``http://my.suyp.com``,都是访问的``http://my.suyp.com/``,所以没有重定向。

    - 如果URL的格式为``http:127.0.1:10229/node/``。尾部如果**缺少``/``将导致重定向**。  
      因为根据约定，URL尾部的``/``表示目录，没有``/``表示文件。所以访问``/node/``时，服务器会自动去该目录下找对应的默认文件或者返回该目录的文件列表。如果访问``/node``的话，服务器会先去找``node``文件，找不到的话会将``node``当成目录重定向到``/node/``，去该目录下找默认文件或者返回该目录的文件列表。
  + [proxy_pass](https://blog.csdn.net/u010433704/article/details/99945557)  
    假设下面四种情况分别用 http://192.168.1.1/proxy/test.html 进行访问。
    - ```python
      location /proxy/ {
        proxy_pass http://127.0.0.1/;
      }
      # 代理到URL：http://127.0.0.1/test.html
      ```
    - ```python
      location /proxy/ {
        proxy_pass http://127.0.0.1/; # （相对于第一种，最后少一个 / ）
      }
      # 代理到URL：http://127.0.0.1/test.html
      ```
    - ```python
      location /proxy/ {
        proxy_pass http://127.0.0.1/aaa/;
      }
      # 代理到URL：http://127.0.0.1/aaa/test.html
      ```
    - ```python
      location /proxy/ {
        proxy_pass http://127.0.0.1/aaa; # （相对于第三种，最后少一个 / ）
      }
      # 代理到URL：http://127.0.0.1/aaatest.html  
      ```
    理解：  
      如果最后有``/``，就是把URL从``location``路由切割，把**后面的部分**放到代理地址的后面，如果没有，就是把**路由加上后面的部分**放到代理地址的后面。（注意: ``http://127.0.0.1``===``http://127.0.0.1/``）。

  ### **推荐配置代理的写法：**
  ```python
  location /proxy/ {
    proxy_pass http://127.0.0.1/;
  }
  location /proxy/ {
    proxy_pass http://127.0.0.1/aaa/;
  }
  # location 的路由最后也加上/
  # proxy_pass 的最后也加上/
  # 好处：访问的地址和真实地址在/proxy/之后是完全一样的，便于理解记忆
  ```
+ Node
	- 全局可跨域
	```javascript
	app.all('*', (req, res, next) => {
		// 设置允许跨域的域名，*代表允许任意域名跨域
		res.header('Access-Control-Allow-Origin', '*');
		// 允许的header类型
		res.header('Access-Control-Allow-Headers', 'content-type');
		// 跨域允许的请求方式
		res.header('Access-Control-Allow-Methods', 'DELETE,PUT,POST,GET,OPTIONS');
        next();
	});
	```
	- 指定接口可跨域
	```javascript
	app.get('/node', (req, res) => {
		// 设置允许跨域的域名，*代表允许任意域名跨域
		res.header('Access-Control-Allow-Origin', '*');
		// 允许的header类型
		res.header('Access-Control-Allow-Headers', 'content-type');
		// 跨域允许的请求方式
		res.header('Access-Control-Allow-Methods', 'DELETE,PUT,POST,GET,OPTIONS');
	});
	```
  注：因为Node的路由是由上到下匹配的，有符合的默认就不继续向下匹配了
    + 指定全局可跨域时，一定要先写`` app.all``
    + 在`` app.all`` 中，一定要加`` next() ``, 来让路由继续向下匹配

### 3）浏览器插件  
在chrome网上商店中搜索 **Allow CORS: Access-Control-Allow-Origin** 插件安装，在需要的时候运行即可。  

注：该插件会把所有请求都加上可跨域响应头，但是这样会导致已经有可跨域响应头的接口报 **允许跨域的值重复** 的错误，因此实用性不高，推荐使用Nginx代理测试。

### 4）[JSONP](https://blog.csdn.net/hansexploration/article/details/80314948)
JSONP是服务器与客户端跨源通信的一种方法。最大特点就是简单适用，老式浏览器全部支持，服务器不用做任何改造。

理论基础：**Web页面上调用js文件时是不受否跨域的影响**（不仅如此，凡是拥有”src”这个属性的标签都拥有跨域的能力，比如``<script>``、``<img>``、``<iframe>``）。

因为JSONP是利用``script``标签的特性来实现跨域的，所以不支持``post``请求。

基本思想：在远程服务器上设法把数据装进 ``js`` 格式的文件里，供客户端调用和进一步处理。

首先，网页动态插入``<script>``元素，由它向跨源网址发出请求。
```javascript
function addScriptTag(src) {
  var script = document.createElement('script');
  script.setAttribute("type","text/javascript");
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  // 这里使用一个文本来模拟jsonp服务端返回的最终数据格式
  // 文本内容：jsonpExe({"data":"我是jsonp的数据"});
  addScriptTag('http://localhost:1000/jsonp.txt?callback=jsonpExe');
}

function jsonpExe(param) {
  // jsonp方式传回来的数据本身就是json对象
  alert(JSON.stringify(param));
}
```
上面代码通过动态添加``<script>``元素，向服务器``localhost:1000``发出请求。注意，该请求的查询字符串有一个``callback``参数，用来指定**回调函数的名字**，这对于JSONP是必需的。

服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。
```javascript
jsonpExe({"data":"我是jsonp的数据"});
```
由于``<script>``元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了``foo``函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用``JSON.parse``的步骤。

或者使用AJAX调用，示例如下：
```javascript
  function getJSONPData() {
    $.ajax({
      type: "get",
      url: 'http://localhost:1000/jsonp.txt',
      dataType: 'jsonp', // 一定要使用 jsonp 类型
      success: function(data) {
        console.log(data);
      },
      error: function(err) {}
    });
  }

  function jsonpExe(param) {
    // jsonp方式传回来的数据本身就是json对象
    alert(JSON.stringify(param));
  }
```
### 5）Canvas中调用image也会有跨域问题
受影响的方法如下：
+ getImageData()：   
  返回一个``ImageData``对象，用来描述canvas区域隐含的像素数据
+ toBlob()：  
  创造``Blob``对象，用以展示canvas上的图片；这个图片文件可以被缓存或保存到本地，由用户代理端自行决定。如不特别指明，图片的类型默认为 ``image/png``，分辨率为``96dpi``。
+ toDataURL() ：  
  返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 ``PNG`` 格式。图片的分辨率为``96dpi``。

下面以``toDataURL() ``为例。

在使用``Canvas``绘制不同域的图片然后转为``Base64``时，会有跨域问题。但是，**不影响Canvas绘制展示图片**。
```HTML
<body>
  <canvas id="myCanvas" width="1920" height="1080" style="border: 2px solid grey">当前浏览器不支持canvas</canvas>
</body>
<script>
  var canvas = document.getElementById("myCanvas")
  var context = canvas.getContext("2d")

  var img = new Image()
  // img.src = './img/思路logo紫.png'; // 同源图片
  img.src = 'http://localhost:8090/CORS/思路logo蓝.png'; // 不同源图片
  //图片加载完后，将其显示在canvas中
  img.onload = function() {
    context.drawImage(this, 0, 0, 1920, 1080) // 改变图片大小到1080*980
    // toDataURL是向canvas转为Base64的一个方法
    console.log(canvas.toDataURL('image/png'));
  }
</script>
```
报错：   
{% asset_img err-CORS4.png %}
{% asset_img err-CORS5.png %}

**解决方式**：
1. 设置图片的``crossOrigin = 'anonymous'``,来让``toDataURL``方法不因跨域报错
2. 设置图片可跨域  
**二者缺一不可**。
```HTML
<body>
  <canvas id="myCanvas" width="1920" height="1080" style="border: 2px solid grey">当前浏览器不支持canvas</canvas>
</body>
<script>
  var canvas = document.getElementById("myCanvas")
  var context = canvas.getContext("2d")

  var img = new Image()
  img.src = 'http://localhost:8090/CORS/思路logo蓝.png'; // 不同源图片
  img.crossOrigin = 'anonymous';
  //图片加载完后，将其显示在canvas中
  img.onload = function() {
    context.drawImage(this, 0, 0, 1920, 1080) // 改变图片大小到1080*980
    // toDataURL是向canvas转为Base64的一个方法
    console.log(canvas.toDataURL('image/png'));
  }
</script>
```

### 6） **表单提交数据不受同源策略的影响** (看例子)

### 7) 不允许IFrame被嵌入

在响应头中有这么一个配置项 **X-Frame-Options**来标识一个页面是否可以被其他页面嵌入。
可选值：
  + deny：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。
  + sameorigin：表示该页面可以在相同域名页面的 frame 中展示。
  + allow-from uri：表示该页面可以在指定来源的 frame 中展示。（uri为指定源的地址）

配置：
  + Tomcat
     在 Tomcat根目录 --> conf --> web.xml 的 web-app 节点下加入如下代码。 
     ```XML
         <!-- 配置页面是否能被其他页面展示 -->
    <filter>
        <filter-name>httpHeaderSecurity</filter-name>
        <filter-class>org.apache.catalina.filters.HttpHeaderSecurityFilter</filter-class>
        <init-param>
            <param-name>antiClickJackingOption</param-name>
            <!-- 配置的具体值 -->
            <param-value>sameorigin</param-value>
            <!-- 当指定部分域可展示时，使用下面代码配置指定域 -->
            <!-- <param-value>http://127.0.0.1/</param-value> -->
        </init-param>
        <async-supported>true</async-supported>
    </filter>
    <filter-mapping>
        <filter-name>httpHeaderSecurity</filter-name>
        <url-pattern>/*</url-pattern>
        <dispatcher>REQUEST</dispatcher>
        <dispatcher>FORWARD</dispatcher>
    </filter-mapping>
     ```
  + Nginx
    配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 'http', 'server' 或者 'location' 的配置中:  
    ``add_header X-Frame-Options sameorigin always;``
    ``add_header X-Frame-Options deny always;``
    ``add_header X-Frame-Options allow-from 'http://127.0.0.1,http://127.0.0.2' always;``
## 小结：
### 推荐做法：
+ **在能随意操作文件的情况优先把资源分类放到一起，这样既不会有跨域请求问题，也方便管理。**
+ **不行的话，使用Nginx代理。**

# 2. 跨域数据存储访问（Cross-origin data storage access）
## 2.1 使用域名（domain）
[document.domain](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy) 属性中存入的是主机信息，并且可以设置为当前域或者**当前域的父域**。如果将其设置为其当前域的父域，则这个较短的父域将**用于后续源检查**。  
另外，任何对document.domain的赋值操作，包括 document.domain = document.domain 都会导致端口号被**重写为 null**。因此 company.com:8080 不能仅通过设置 document.domain = "company.com" 来与company.com 通信。**必须在他们双方中都进行赋值，以确保端口号都为 null 。**

由于以上的情况，我们可以在多个只有二级域名不同的网页进行以下操作。

注：
+ [域名](https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D/86062?fr=aladdin)
+ [域名分类](https://www.zhihu.com/question/29998374)  

## 2.1.1 Cookie
Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置 ```document.domain```共享 ```Cookie```。

举例来说，A网页是**http://w1.example.com/a.html**，B网页是**http://w2.example.com/b.html**，那么只要设置相同的document.domain，两个网页就可以共享Cookie。
```javascript
document.domain = 'example.com';
```
现在，A网页通过脚本设置一个 Cookie。
```javascript
document.cookie = "test1=hello";
```
B网页就可以读到这个 Cookie。
```javascript
var allCookie = document.cookie;
```

另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，这样二级域名和三级域名不用做任何设置，都可以读取这个Cookie。
## 2.1.2 DOM
如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的 ```document.domain```属性，就可以规避同源政策，拿到DOM。

# 3. 跨域脚本API访问（Cross-origin script API access）
如果两个网页不同源，就无法拿到对方的DOM。典型的例子是``iframe``窗口和``window.open``方法打开的窗口，它们与父窗口无法通信。

比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。
```javascript
document.getElementById("myIFrame").contentWindow.document
// Uncaught DOMException: Blocked a frame with origin "http://127.0.0.1:5500" from accessing a cross-origin frame.
```
上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。

反之亦然，子窗口获取主窗口的DOM也会报错。
```javascript
window.parent.document.body
// Uncaught DOMException: Blocked a frame with origin "http://localhost:1000" from accessing a cross-origin frame.
```

对于完全不同源的网站，目前有四种方法，可以解决跨域窗口的通信问题。
+ 片段识别符（``fragment identifier``）
+ window.name
+ 跨文档通信API（``Cross-document messaging``）
+ WebSocket

## 2.2.1 片段识别符
片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如``http://example.com/x.html#fragment``的``#fragment``。**如果只是改变片段标识符，页面不会重新刷新**。

父窗口可以把信息，写入子窗口的片段标识符。
```javascript
var srcStr = document.getElementsByClassName("iframe")[0].src.split('#')[0] + '#' + encodeURI(value);
$('.iframe').attr('src', srcStr);
```
子窗口通过监听hashchange事件得到通知。
```javascript
window.onhashchange = checkMessage;

function checkMessage() {
  var message = window.location.hash;
  // ...
}
```
同样的，子窗口也可以改变父窗口的片段标识符。
```javascript
parent.location.href= target + "#" + hash;
```
注意：**如果修改后的hash值和原来的一样，不会进片段识别符改变的监听**

## 2.2.2 window.name
浏览器窗口有``window.name``属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。

父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。
```javascript
window.name = '{"name": "lisi"}';
```
接着，子窗口跳回一个与主窗口同域的网址。
```javascript
// 把子页面的window.location 设置为域和父页面同源的
window.location = 'http://127.0.0.1:5500/windowName/testWN.html';
```
然后，主窗口就可以读取子窗口的window.name了。
```javascript
var data = document.getElementById('myFrame').contentWindow.name;
```
这种方法的优点是，``window.name``容量很大，可以放置非常长的字符串；缺点是必须监听子窗口``window.name``属性的变化，影响网页性能。

## 2.2.3 [**window.postMessage**](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)
上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（``Cross-document messaging``）。

这个API为window对象新增了一个方法 ``window.postMessage``，允许跨窗口通信，不论这两个窗口是否同源，只要你能获取到目标对象的window对象。

举例来说，父窗口``http://aaa.com``向子窗口``http://bbb.com``发消息，调用``postMessage``方法就可以了。
```javascript
var popup = window.open('http://aaa.com', 'title');
popup.postMessage('Hello World!', 'http://aaa.com');
```
``postMessage``方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（``origin``），即”协议 + 域名 + 端口”。也可以设为``*``，表示不限制域名，向所有窗口发送.

子窗口向父窗口发送消息的写法类似。
```javascript
window.opener.postMessage('Nice to see you', 'http://bbb.com');
```
注：``window.opener`` 属性是一个可读可写的属性，可返回对**创建该窗口的 Window 对象的引用**。

父窗口和子窗口都可以通过``message``事件，监听对方的消息。
```javascript
window.addEventListener('message', function(e) {
  console.log(e.data);
},false);
```
下面的例子是，子窗口通过``event.source``属性引用父窗口，然后发送消息。
```javascript
window.addEventListener('message', receiveMessage);
function receiveMessage(event) {
  event.source.postMessage('Nice to see you!', '*');
}
```
``event.origin``属性可以过滤不是发给本窗口的消息。
```javascript
window.addEventListener('message', receiveMessage);
function receiveMessage(event) {
  if (event.origin !== 'http://bbb.com') return;
  if (event.data === 'Hello World') {
      event.source.postMessage('Hello', event.origin);
  } else {
    console.log(event.data);
  }
}
```
## message事件的事件对象event，提供以下三个属性。
+ **event.source：发送消息的窗口**
+ **event.origin: 消息发向的网址**
+ **event.data: 消息内容**

下面的例子是，子窗口通过``event.source``属性引用父窗口，然后发送消息。
```javascript
window.addEventListener('message', receiveMessage);
function receiveMessage(event) {
  event.source.postMessage('Nice to see you!', '*');
}
````
``event.origin``属性可以过滤不是发给本窗口的消息。
```javascript
window.addEventListener('message', receiveMessage);
function receiveMessage(event) {
  if (event.origin !== 'http://bbb.com') return;
  if (event.data === 'Hello World') {
      event.source.postMessage('Hello', event.origin);
  } else {
    console.log(event.data);
  }
}
```

## **通过window.postMessage，读写其他窗口的 LocalStorage 或者 SessionStorage也成为了可能。**  

下面是一个例子，主窗口写入``iframe``子窗口的``localStorage``。
```javascript
window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') {
    return;
  }
  var payload = JSON.parse(e.data);
  localStorage.setItem(payload.key, JSON.stringify(payload.data));
};
```
上面代码中，子窗口将父窗口发来的消息，写入自己的``LocalStorage``。

父窗口发送消息的代码如下。
```javascript
var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
win.postMessage(JSON.stringify({key: 'storage', data: obj}), 'http://bbb.com');
```
加强版的子窗口接收消息的代码如下。
```javascript
window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') return;
  var payload = JSON.parse(e.data);
  switch (payload.method) {
    case 'set':
      localStorage.setItem(payload.key, JSON.stringify(payload.data));
      break;
    case 'get':
      var parent = window.parent;
      var data = localStorage.getItem(payload.key);
      parent.postMessage(data, 'http://aaa.com');
      break;
    case 'remove':
      localStorage.removeItem(payload.key);
      break;
  }
};
```
加强版的父窗口发送消息代码如下。
```javascript
var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
// 存入对象
win.postMessage(JSON.stringify({key: 'storage', method: 'set', data: obj}), 'http://bbb.com');
// 读取对象
win.postMessage(JSON.stringify({key: 'storage', method: "get"}), "*");
window.onmessage = function(e) {
  if (e.origin != 'http://aaa.com') return;
  // "Jack"
  console.log(JSON.parse(e.data).name);
};
```
**SessionStorage同理。**
## 2.2.4 [WebSocket](http://www.ruanyifeng.com/blog/2017/05/websocket.html)
WebSocket是一种通信协议，使用``ws://（非加密）``和``wss://（加密）``作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。

下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。
```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```
上面代码中，有一个字段是``Origin``，表示该请求的请求源（``origin``），即发自哪个域名。

正是因为有了``Origin``这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。
```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```
示例：  
+ Node服务端:
```javascript
const WebSocket = require('ws');

// websocket服务的端口
const wsport = 3006;
var wss = new WebSocket.Server({
  port: wsport,
  path: '/ws'
});
wss.on('connection', function connection(ws) {
  console.log('ws连接')
  ws.isAlive = true;
  ws.on('pong', heartbeat);
  ws.on('message', function incoming(message) {
    message = JSON.parse(message);
    // 推送消息
    ws.send(JSON.stringify(message));
  });
});
// 定时每30s发送ping监测连接是否中断
const interval = setInterval(function ping() {
  wss.clients.forEach(function each(ws) {
    if (ws.isAlive === false) return ws.terminate();
    ws.isAlive = false;
    ws.ping();
  });
}, 30000);
```
+ 页面1：
```javascript
var ws = new WebSocket('ws://localhost:3006/ws', 'suyp');
ws.onopen = function(param) {
	console.log('WebSocket连接成功！');
	ws.onmessage = function(param) {
		console.log('这是WebSocket接收的消息 --- ' + param.data);
    // 接收消息这里推荐写try catch 来捕捉错误，因为消息有可能不是JSON格式
		try {
			var message = JSON.parse(param.data);
		} catch (e) {
			console.log(e);
		}
		if (message) {
			switch (message.key) {
				case 'closeInfoWindow':
					console.log('弹窗已关闭');
					break;
				default:
					break;
			}
		}
	}
	ws.onclose = function() {
		console.log('ws关闭了');
	}
}
```
+ 页面2
```javascript
  // 向父页面发送消息,来关闭弹窗
  function closeInfowWindow2() {
    if (ws) {
      ws.send(JSON.stringify({
        key: 'closeInfoWindow',
        msg: ''
      }))
    }
  }
```
## 小结
**跨域通信和调用方法推荐做法：**
+ Nginx代理到一起 （最好）
+ 使用postMessaget通信 （挺好）


# 参考资料
+ [什么是JSONP --- HansExploration](https://blog.csdn.net/hansexploration/article/details/80314948)
+ [JSONP --- 百度百科](https://baike.baidu.com/item/jsonp/493658?fr=aladdin)
+ [浏览器同源政策及其规避方法 --- 阮一峰](https://www.techug.com/post/same-origin-policy.html)
+ [WebSocket 教程 --- 阮一峰](http://www.ruanyifeng.com/blog/2017/05/websocket.html)
+ [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)
