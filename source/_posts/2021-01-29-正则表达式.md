---
title: 正则表达式
author: 吴俊
authorLink: https://github.com/Patrick-Jun/
excerpt: 正则表达式语法学习，常用正则表达式设计
cover: 2021/01/29/正则表达式/cover.png
thumbnail: 2021/01/29/正则表达式/cover.png
categories:
  - - JavaScript
    - 正则表达式
tags:
  - 正则表达式
toc: true
date: 2021-01-29 20:43:40
updated: 2021-01-29 20:43:40
---

PPT在线查看(可下载)：https://www.yuque.com/heq286/xakx9r/10490826

视频回放地址：https://www.bilibili.com/video/BV1Ft4y1B768/

<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=628889616&bvid=BV1Ft4y1B768&cid=289579962&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe>
</div>

> 以下内容为基本语法，详细请见PPT

# 1 界定符

**定义**：表示一个正则表达式的开始和结束

在JavaScript中，界定符以斜线（`/`）开始和结束：

``` javascript
const reg = /正则表达式/;
```

**可以这样理解**：字符串是通过单引号或者双引号界定，那么正则的界定就好理解了吧。

# 2 原子

**定义**：正则表达式中最小的匹配单位

分为：可见原子、不可见原子（空格、换行符等）

``` javascript
const reg = /A/;
const reg = /,/;
const reg = / /;
```

以上正则表达式中，均只有一个原子。

**可以这样理解**：一篇文章的最小单位是一个文字或者一个单词，他们组合在一起就是一篇文章，正则表达式也是有原子组合而来的。

# 3 元字符

**定义**：一系列原子的集合

**作用**：定义原子的筛选方式；对某一类原子归类缩写；

**有三种筛选方式**：

``` javascript
原子|原子    // 表示：或（匹配其中一个原子即可）
[原子原子...]  // 表示：任一（匹配括号里的任一一个原子即可，原子之间不用竖线）
[^原子原子...] // 表示：除此之外（和前一种情况相反）
```

中括号中，如果原子是连续的（ASCII码），那么可以用横线（`-`）表示连续：

``` javascript
[0123456789] = [0-9]
[abcdefghijklmn] = [a-n]
```

**内置原子集合**：

| **元字符** | **解释**                         | **等价于**        |
| ---------- | -------------------------------- | ----------------- |
| **.**      | 除换行符之外任意一个字符         |                   |
| **\d**     | 匹配任意一个十进制数             | **[0-9]**         |
| **\D**     | 匹配任意一个非十进制数           | **[^0-9]**        |
| **\s**     | 匹配一个不可见原子               | **[\f\n\r\t\v]**  |
| **\S**     | 匹配一个可见原子                 | **[^\f\n\r\t\v]** |
| **\w**     | 匹配任意一个数字、字母、下划线   | **[0-9a-zA-Z_]**  |
| **\W**     | 匹配任意一个非数字、字母、下划线 | **[^0-9a-zA-Z_]** |

**可以这样理解**：单词可以组成一句话，文章是由很多句话组成。元字符也是对一类原子组成的一小段，最终这些元字符汇聚就可以组成正则表达式。

# 4 量词

**定义**：描述原子连续出现的次数

**用法**：

``` javascript
原子{n}      // 表示要前面紧邻的这个原子要匹配n次
原子{n,}     // 表示要前面紧邻的这个原子要匹配大于等于n次：半开半闭区间 [n, +无穷)
原子{n,m}    // 表示要前面紧邻的这个原子要匹配大于等于n次，小于等于m次：[n, m]
```

**特殊量词**：

| **特殊量词** | **解释**                           | **等价于** |
| ------------ | ---------------------------------- | ---------- |
| *        | 匹配>=0次之前的原子（可存在）      | {0,}       |
| **+**        | 匹配1次或多次之前的原子（存在）    | {1,}       |
| **?**        | 匹配0次或1次之前的原子（可有可无） | {0,1}      |

示例：

``` javascript
/ES\d{4}/     // 可以匹配到：ES000 ES2015 ES2020等
/go{2,}gle/   // 可以匹配到：google gooooooogle等
```

# 5 边界控制

**定义**：对目标位置的控制，以`^`表示开始，以`$`表示结束。

**用法**：

``` javascript
/go{2,}gle/   // "This is google website!"  可以匹配

/^go{2,}gle/  // "This is google website!"  匹配失败
              // "google"  可以匹配
```

此外边界控制还有模式单元`()`，小括号的作用可以将整体作为一个原子。

``` javascript
[Dd]  // 2个原子
(D|d) // 1个原子
```

# 6 修正模式

**定义**：给正则表达式的匹配过程设定一种模式

| **修正表达式** | **解释**                                               |
| -------------- | ------------------------------------------------------ |
| **i**          | 忽略字母大小写                                         |
| **g**          | 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） |
| **m**          | 执行多行匹配。                                         |

**用法**：

``` javascript
/正则表达式/i
```

# 7 贪婪模式和懒惰模式

**定义**：

贪婪模式：在条件允许的范围内，利益最大化（得寸进尺）

懒惰模式：达到最低标准即可（不思进取）

**用法**：量词后面加`？`表示懒惰模式

``` javascript
tasssssk   /s+/  匹配结果：sssss  (贪婪模式，可以匹配1个以上的s，那就全匹配)
tasssssk   /s+?/ 匹配结果：s      (懒惰模式，可以匹配1个以上的s，那最低标准1个s)
```

| **贪婪模式**      | **懒惰模式**       | **解释**        |
| ----------------- | ------------------ | --------------- |
| **?**             | **??**             | 匹配0个或1个    |
| **+**             | **+?**             | 匹配1个或多个   |
| *                 | *？              | 匹配0个或多个   |
| **{n}**           | **{n}?**           | 匹配n个         |
| **{n,m}** | **{n,m}?** | 匹配n个或者m个  |
| **{n,}**          | **{n,}?**          | 匹配n个或者多个 |

# 8 神奇的问号?

**正向断言**：`(?=原子)` 表示后面必须接正向断言的原子，且匹配结果不包括该原子

**负向断言**：`(?!原子)`表示后面不能接正向断言的原子，匹配结果不包括该原子

``` javascript
/string(?=s)/   可以匹配：strings (匹配结果：stirng)  不可以匹配：stringS stringa
/string(?!s)/   可以匹配：stringS (匹配结果：string)  不可以匹配：strings
```

`?:`产生无编号分组：

``` javascript
正则：/(ab)c(ba)/   /(?:ab)c(ba)/  /((a)(b))(c)/
编号：   1    2               1         1    2
```

