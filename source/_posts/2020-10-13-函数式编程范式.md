---
title: 函数式编程范式
author: 吴俊
authorLink: https://github.com/Patrick-Jun
excerpt: 函数式编程是一种编程范式
cover: 2020/10/13/函数式编程范式/cover.jpg
thumbnail: 2020/10/13/函数式编程范式/cover.jpg
categories:
  - - JavaScript
    - 编程范式
tags:
  - JavaScript

toc: true
date: 2020-10-13 10:16:47
updated: 2020-11-02 14:00:00
---

# 1 函数式编程概念

## 1.1 定义

函数式编程（Functional Programming: FP）是一种编程范式（指计算机中编程中的典范模式或方法），用于描述数据（函数）之间的映射关系。

函数式编程中的函数不是指程序中的函数（方法），而是数学中的函数（映射关系），如：`y = f(x)`，指`x`和`y`之间的关系。

常见的编程范式有：函数式编程、程序编程、面向对象编程、指令式编程、声明式编程等。

> 指令式编程：主要思想是关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么。

> 声明式编程：以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。SQL 语句就是最明显的一种声明式编程的例子。

现代编程语言的发展趋势是支持多种范式，如C#、Java 8+、Kotlin、ES6+。

## 1.2 特点

1. 代码简洁：函数式编程⼤大量量使⽤用函数，减少了了代码的重复；

2. 接近自然语言，易于理解：

   ``` js
   var result = （1 + 2）* 3 - 4;
   
   var result = subtract(multiply(add(1, 2), 3), 4);
   ```

3. 函数是“第一等公民”：函数与其他数据类型一样，处于平等地位，可以赋值给其它变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值；

4. 闭包和高阶函数：函数式编程会使用较多的闭包和高阶函数；

5. 没有“副作用”，方便与代码管理和单元测试：`副作用` 指函数内部与外部互动(最典型的情况，就是修改全局变量量的 值)，产⽣生运算以外的其他结果。函数式编程强调没有"副作用"，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他⾏为，尤其是不得修改外部变量的值；

6. 不修改变量：不会保留计算中间的结果，不修改变量，使用参数保留状态；

7. 引用透明：函数的运行不依赖于外部变量或"状态"，只依赖于输入 的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。

## 1.3 基本概念

①函数式编程的思维方式：

把现实世界的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象）

②程序的本质：

根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数。

③函数`y=f(x)`：

x → f(映射) → y

{% asset_img 1652dd18eb23b0d6.jpg %}

图1 从x到y的函数关系

{% asset_img 1652dd18eb0bd7f6.jpg %}

图2 从x到y不是函数关系

④纯函数：相同的输入始终要得到相同的输出

⑤函数式编程是用来描述数据（函数）之间的映射

# 2 头等函数

## 2.1 函数是一等公民

- 函数可以存储在变量中
- 函数可以作为参数
- 函数可以作为返回值

函数可以存储在变量中：

```js
// 把函数赋值给变量
const fn = () => {
  console.log('2.1 函数可以存储在变量中');
};
fn();

// 属性赋值示例
// const objController = {
//   getKeys(obj) {
//     return Object.keys(obj);
//   },
// };
// 优化
// 上面代码中getKeys方法和内部调用Object.keys方法的参数和返回值一样，所以可以改写成下面
const objController = {
  getKeys: Object.keys,
};
console.log(objController);

const my = { name: 'Patrick Jun', constellation: 'Virgo' };
console.log(objController.getKeys(my));
```

## 2.2 高阶函数

- 把函数作为参数传递给另一个函数
- 可以把函数作为另一个函数的返回结果

### 2.2.1 函数作为参数

``` js
// 遍历
function forEach(arr, fn) {
  for (let i = 0; i < arr.length; i++) {
    fn(arr[i], i);
  }
}
// 筛选，返回符合条件的元素组成的新数组
function filter(arr, fn) {
  const results = [];
  for (const item of arr) {
    if (fn(item)) {
      results.push(item);
    }
  }
  return results;
}
const colors = ['#FF0000', '#00FF00', 'blue'];
forEach(colors, (item, index) => {
  console.log(index + 1, item);
});
console.log(
  filter(colors, (item) => item.length === 7),
);
```



### 2.2.2 函数作为返回值

```js
function makeFn() {
  const msg = 'hello function';
  return function () {
    console.log(msg);
  };
}
const fn = makeFn();
fn();
// makeFn()()

// 模拟lodash中的once函数 对一个函数只执行一次的函数(例如支付,不管用户点击多少次按钮，都只执行一次)
function once(func) {
  let done = false;
  return function () {
    if (!done) {
      done = true;
      func.apply(this, arguments);
    }
  };
}
const pay = once((money) => {
  console.log(`支付${money}元`);
});
pay(20);  // 支付20元
pay(30);
pay(40);
```

### 2.2.3 使用高阶函数意义

- 抽象可以帮我们屏蔽细节，只需要关注我们的目标
- 高阶函数用来抽象通用的问题

### 2.2.4 常用高阶函数模拟

- map 通过指定函数处理数组的每个元素，并返回处理后的数组。

```js
function map(arr, fn) {
  const res = [];
  for (const val of arr) {
    res.push(fn(val));
  }
  return res;
}
let arr = [1, 2, 3, 4, 5];
arr = map(arr, (item) => item * item);
console.log(arr); //[ 1, 4, 9, 16, 25 ]
```

- every 用于检测数组所有元素是否都符合指定条件

```js
function every(arr, fn) {
  let res = true;
  for (const val of arr) {
    res = fn(val);
    if (!res) {
      break;
    }
  }
  return res;
}
const arr1 = [1, 2, 3, 4, 5];
const arr2 = [4, 5, 6, 7];

const res1 = every(arr1, (item) => item > 3);
console.log(res1);  // false
const res2 = every(arr2, (item) => item > 3);
console.log(res2);  // true
```

- some 判断数组中是否至少有一个元素满足条件

```js
function some(arr, fn) {
  let res = false;
  for (const val of arr) {
    res = fn(val);
    if (res) {
      break;
    }
  }
  return res;
}
const arr1 = [1, 2, 3, 4, 5];
const arr2 = [1, 3, 5, 7];

const res1 = some(arr1, (item) => item % 2 === 0);
console.log(res1);  // true
const res2 = some(arr2, (item) => item % 2 === 0);
console.log(res2);  // false
```

- find 返回数组中满足提供的测试函数的第一个元素的值，如果未找到，则返回undefined

``` js
function find(arr, fn) {
  for (const item of arr) {
    if (fn(item)) { return item; }
  }
  return undefined;
}
const arr1 = [1, 2, 3, 4, 5];

const res1 = find(arr1, (item) => item % 2 === 0);
console.log(res1);  // 2
const res2 = find(arr1, (item) => item === 8);
console.log(res2);  // undefined
```

- findIndex 找到满足条件的第一个元素，返回其位置，如果未找到，则返回-1

``` js
function findIndex(arr, fn) {
  for (let i = 0; i < arr.length; i++) {
    if (fn(arr[i])) {
      return i;
    }
  }
  return -1;
}
const arr1 = [1, 2, 3, 4, 5];

const res1 = findIndex(arr1, (item) => item % 2 === 0);
console.log(res1);  // 1
const res2 = findIndex(arr1, (item) => item === 8);
console.log(res2);  // -1
```

# 3 闭包

## 3.1 定义

函数和其周围的状态的引用捆绑在一起形成的闭包。

- 可以在另一个作用域中调用一个函数内部的函数并访问到该函数的作用域中的成员；
- 闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕后会从执行栈上删除，**但是堆上作用域成员因为被外部引用而不能被释放**，因此内部函数依然可以访问到作用域的成员；

## 3.2 案例

```js
function makePower(power) {
  return function (number) {
    return number ** power;
  };
}
// 平方
const power2 = makePower(2);
// 立方
const power3 = makePower(3);
console.log(power2(5));
console.log(power2(2));
console.log(power3(4));

function makeSalary(base) {
  return function (performance) {
    return base + performance;
  };
}
// 底层打工人
const sallaryLevel1 = makeSalary(1000);
// 高级打工人
const sallaryLevel2 = makeSalary(10000);
console.log(sallaryLevel1(100));  // 1100
console.log(sallaryLevel1(120));  // 1120
console.log(sallaryLevel2(30000));  // 40000
```

打开Chrome开发者工具 > Sources ：

- Call Stack(函数调用栈) 

- Scope(作用域) ： Global(var 全局) 、 Local(局部) 、 Closure(闭包) 、 Script(let 作用域)

``` js
// 查看函数栈和闭包作用域成员的访问
function makeSalary() {
  let base = 1000;
  return function (performance) {
    // debugger;
    base += 1;
    return base + performance;
  };
}

const sallary = makeSalary();
console.log(sallary(100));
console.log(sallary(120));
```



# 4 纯函数

## 4.1 概念

**相同的输入永远会等到相同的输出**，没有任何可观察的副作用

- slice 和 splice 分别：纯函数和不纯函数
- slice 返回数组中的指定部分，不会改变原数组
- splice 对数组进行操作返回该数组，会改变原数组

``` javascript
// 纯函数 slice
const numbers = [1, 2, 3, 4, 5];
console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]
console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]
console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]
// 不纯函数 splice
console.log(numbers.splice(0, 3)); // [ 1, 2, 3 ]
console.log(numbers.splice(0, 3)); // [ 4, 5 ]
console.log(numbers.splice(0, 3)); // []
// 纯函数
function getSum(a, b) {
  return a + b;
}
console.log(getSum(1, 2)); // 3
console.log(getSum(1, 2)); // 3
console.log(getSum(1, 2)); // 3
```

- 函数式编程不会保留计算中间结果，所以变量是不可变的（无状态）
- 我们可以把一个函数的执行结果交给另一个函数去处理

## 4.2 lodash

官网：[lodash](http://lodash.com/)
lodash是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法。

```js
const _ = require('lodash');

const arr = ['Tom', 'Jon', 'Kate'];
console.log(_.first(arr));
// console.log(_.last(arr));
// console.log(_.toUpper(_.last(arr)));
console.log(_.reverse(arr));
console.log(_.first(arr));

console.log(_.reverse(arr));
console.log(_.each(arr, (item, index) => {
  console.log(item, index);
}));

// _.isEmpty(value); // 判断一个value 是否是empty(null,[],{}....)
```

## 4.3 纯函数的好处

- 可缓存：因为纯函数相同的输入永远会等到相同的输出，所以可以把纯函数结果缓存

``` javascript
// 记忆函数
const _ = require('lodash');

function getArea(r) {
  console.log(r);
  return Math.PI * r * r;
}
// 这里使用lodash中的记忆函数
const getAreaWithMemory = _.memoize(getArea);
console.log(getAreaWithMemory(4));
console.log(getAreaWithMemory(4));
console.log(getAreaWithMemory(5));

// js模拟 memoize 方法的实现
function memoize(f) {
  const cache = {};
  return function () {
    const key = JSON.stringify(arguments);
    cache[key] = cache[key] || f.apply(f, arguments);
    return cache[key];
  };
}

const getAreaWithMemory = memoize(getArea);
console.log(getAreaWithMemory(4));
console.log(getAreaWithMemory(4));
console.log(getAreaWithMemory(5));
```

- 可测试：纯函数让测试更加方便，对单元化测试很友好
- 并行处理：
	- 在多线程环境下并行操作共享的内存数据很可能会出现意外情况
	- 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker）

## 4.4 副作用

纯函数：指**相同的输入永远会得到相同的输出**，而且没有可观察的**副作用**，而副作用让一个函数变的不纯（如下），纯函数根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用

```js
// 不纯的
let mini = 18;
function checkAge(age) {
  return age >= mini;
}

// 纯的（有硬编码，后续可以通过柯里化解决）
function checkAge2(age) {
  let mini = 18;
  return age >= mini;
}
```

副作用的来源：

- 配置文件

- 数据库

- 获取用户的输入：

  所有的外部交互都有可能代理副作用，副作用也是的方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序员带来不确定性，但是副作用不可能完全禁止，尽可能控制他们在可控范围内发生。

# 5 柯里化

柯里化（curry：咖喱）可以把多元函数转化成一元函数

- 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
- 然后返回一个新的函数接受剩余的参数，返回结果

## 5.1 柯里化示例(问题回顾)

解决上面硬编码问题：

``` js
// 普通纯函数
function checkAge(age, min) {
  return age >= min;
}
console.log(checkAge(20, 18));  // true
console.log(checkAge(17, 18));  // false
console.log(checkAge(24, 22));  // true
```

上面代码可以发现当基准值时`18`时，`18`是重复的 使用之前所学的闭包处理

```js
// 函数的柯里化
function checkAge(min) {
  return function (age) {
    return age >= min;
  };
}

const checkAge18 = checkAge(18);
const checkAge22 = checkAge(22);

console.log(checkAge18(17)); // false
console.log(checkAge18(20)); // true
console.log(checkAge22(20)); // false
console.log(checkAge22(30)); // true
```

使用ES6改造上面`checkAge`函数：

```js
let checkAge = min => age => age >= min;
```

## 5.2 lodash.curry(fn)

- _.curry(fn)
	- [https://www.lodashjs.com/docs/lodash.curry](https://www.lodashjs.com/docs/lodash.curry)
	- 功能 创建一个函数，该函数接受fn的参数。如果fn所需的参数都被提供则执行fn并返回结果，否则**继续返回该函数并等待接收剩余的参数**。可以使用 fn.length 强制需要累积的参数个数。

```js
const _ = require('lodash')

function getSum(a, b, c) {
    return a + b + c
}
const curried=_.curry(getSum);
console.log(curried(2, 3, 4));  // 9
console.log(curried(2)(3)(4));  // 9
console.log(curried(2)(3, 4));  // 9
console.log(curried(2, 3)(4));  // 9
```

- 案例

```js
const _ = require('lodash');
const match = _.curry((reg, str) => {
  return str.match(reg);
});
// 匹配所有数字
const hasSpace = match(/\s+/g);
// 匹配所有空白字符
const hasNumber = match(/\d+/g);
console.log(hasSpace('helloword')); // null
console.log(hasNumber('123213 123')); // ["123213"， "123"]
console.log(hasNumber('helloword')); // null

const filter = _.curry((func, array) => {
  return array.filter(func);
});
console.log(filter(hasSpace, ['Patrick Jun', 'Patrick_Jun'])); // ["Patrick Jun"]

const findSpace = filter(hasSpace);
console.log(findSpace(['Patrick Jun', 'Patrick_Jun'])); // ["Patrick Jun"]
```

- 模拟lodash中的curry方法

```js
function curry(func) {
  return function curriedFn(...args) {
    // 判断形参和实参的个数，
    // 如果 实参个数<形参个数,将返回一个函数（该函数内如将再次调用curriedFn, 将第一次传入的参数和第二次传入的参数拼接起来。例如curried(2,3)(4) 第一次传入2,3，第二次传入4，这里将会返回curriedFn（2,3,4）
    // 否则返回传入的func 例如curried(2,3,4),直接返回传入的getSum(2,3,4),返回结果就是9
    if (args.length < func.length) {
      return function () {
        // 将...args与...arguments拼接传递给curriedFn（例如curried(2,3)(4)，这里就会将传递的2,3和4拼接起来）
        return curriedFn(...args, ...arguments);
      };
    }
    return func(...args);
  };
}

function getSum(a, b, c) {
  return a + b + c;
}
const curried = curry(getSum);
console.log(curried(2, 3)(4)); // 9
console.log(curried(2)(3, 4)); // 9
```

## 5.3 总结

- 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
- 这是一种对函数参数的’缓存’（闭包）
- 让函数变的更灵活，让函数的粒度更小
- 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能

# 6 函数组合

## 6.1 概念

函数组合(compose):如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数

- 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果
- **函数组合默认是从右到左执行**

``` js
// 函数组合演示
function compose(f, g) {
  return function (value) {
    return f(g(value));
  };
}

function reverse(array) {
  return array.reverse();
}

function first(array) {
  return array[0];
}

const last = compose(first, reverse);

console.log(last([1, 2, 3, 4])); // 4
```

## 6.2 lodash组合函数

lodash中组合函数`flow()`或者`flowRight()`，他们都可以组合多个函数

`flow`和`flowRight`会创建一个函数，返回结果是调用提供函数的结果。提供函数会连续调用，每个提供函数传入的参数都是前一个函数返回的结果。

- `flow()`是从左到右运行
- `flowRight()`是从右到左运行，使用的更多一些

```js
const _ = require('lodash');

const reverse = (arr) => arr.reverse();
const first = (arr) => arr[0];
const toUpper = (s) => s.toUpperCase();
const f = _.flowRight(toUpper, first, reverse);
console.log(f(['one', 'two', 'three']));  // ???
```

模拟`lodash`中的`flowRight()`方法：

数组中的[reduce()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) ：对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。

``` js
function compose(...args) {
  return function (val) {
    return args.reverse().reduce((acc, fn) => {
      return fn(acc);
    }, val);
  };
}

// ES6
// const compose = (...args) => (val) => args.reverse().reduce((acc, fn) => fn(acc), val);
```

图解步骤：

{% asset_img 20201102142854.png %}

## 6.3 结合律

函数的组合要满足结合律

例如`compose(f,g,h)`，我们既可以先把`f`和`g`组合在一起，还可以先把`g`和`h`组合

```js
let f = compose(f, g, h);
console.log(compose(compose(f, g), h) == compose(f, compose(g, h))); //true
console.log(compose(f, g, h) == compose(f, compose(g, h))); //true

const _ = require('lodash')
// 下面三种写法结果运行一样
const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse);
const f1 = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse));
const f2 = _.flowRight(_.toUpper, _.first, _.reverse);

console.log(f(['one', 'two', 'three']) === f1(['one', 'two', 'three'])); // true
console.log(f(['one', 'two', 'three']) === f2(['one', 'two', 'three'])); // true
console.log(f1(['one', 'two', 'three']) === f2(['one', 'two', 'three'])); // true
```

## 6.4 实战

题目：将`NEVER SAY DIE` 转换为 `never-say-die`;

思路：小写，分割，join

`'NEVER SAY DIE'.toLowerCase().split(' ').join('-');`

分析：

- 函数组合只接受一个参数
- 柯里化可以将多元函数转化成一元函数
- 柯里化可以传递一部分参数，然后返回一个新的函数接受剩余的参数。

``` js
const _ = require('lodash');

// _.toLower()

// _.split()
// 因为我们需要传入str变量，所以str放在最后面传入，以下同理
const split = _.curry((symbol, str) => _.split(str, symbol));

// ._join
const join = _.curry((symbol, array) => _.join(array, symbol));

// log用来检测数据管道中，哪部分值有错误
const log = (v) => {
  console.log(v);
  // 继续返回值给下一个fn
  return v;
};

const f = _.flowRight(join('-'), log, split(' '), log, _.toLower);
console.log(f('NEVER SAY DIE')); // never-say-die


// // 考虑到数据管道很长的情况，如果多次log，打印的数据不够直观，于是改造log
// const _ = require('lodash');

// const trace = _.curry((tag, v) => {
//   console.log(tag, v);
//   return v;
// });

// const split = _.curry((symbol, str) => _.split(str, symbol));
// const join = _.curry((symbol, arr) => _.join(arr, symbol));
// const f = _.flowRight(join('-'), trace('after split：'), split(' '), trace('after toLower：'), _.toLower);
// console.log(f('NEVER SAY DIE'));
```

# 7 总结

1. 函数式编程是一种强调以函数使用为主的软件开发风格；
2. 在函数式编程里面，将多个不同函数组合是一个非常非常非常重要的思想；
3. 纯函数指没有副作用的函数，相同的输入有相同的输出；
4. 函数式编程将函数视为积木，通过一等高阶函数来提高代码的模块化和可重用性。

通过柯里化将多元函数转化成一元函数，然后将柯里化后的函数，通过函数组合的方式合成一个组合函数。



进阶内容：`lodash/fp`、`函子`；（笔者还没学明白）

参考文章：

> 概念定义特点：https://juejin.im/post/6858129115598635015

> 函数式编程讲解：https://juejin.im/post/6844903743117361165

> 函数式编程讲解：https://juejin.im/post/6844903655397654535

> 拉勾教育大前端训练营笔记： https://zhuanlan.zhihu.com/p/162839608

