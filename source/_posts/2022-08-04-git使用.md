---

title: git使用
author: 喻双
authorLink: <https://github.com/geminiyu233>
excerpt: 本文主要讲解了关于 git使用 的相关知识。
cover: 2022/08/04/git使用/cover.jpeg
thumbnail: 2022/08/04/git使用/cover.jpeg
categories:

- - JavaScript
- 工具使用

tags:

- JavaScript
toc: true
date: 2022-08-04 17:34:26

---

# 1 前言

读完全文，希望你能明白：

- [什么是git](https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000)
- [集中式VS分布式：Git VS SVN](<https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248>)
- git常用使用场景及使用方法

# 2 本地/远程仓库

## 2.1 创建版本库

>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。

1. 本地创建一个文件夹
2. 把这个目录变成Git可以管理的仓库

```js
$ git init
Initialized empty Git repository in /Users/yushuang/Documents/技术分享/test1/.git/
```

瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的人可以发现当前目录下多了一个.git的目录，这个目录是Git用来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。

如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见

```js
git add file1.txt
git add file2.txt file3.txt
git commit -m "add 3 files." 
```

## 2.2 添加远程库

> 通过以上操作，现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。

我们在Github上创建一个仓库，成功后会看到以下截图
![Github成功创建仓库](1.png)

现在，我们根据GitHub的提示，在本地的`test1`仓库下运行命令：

```js
git remote add origin https://github.com/geminiyu233/test1.git
```

添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。

下一步，就可以把本地库的所有内容推送到远程库上：

```js
$ git push -u origin master
Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Writing objects: 100% (3/3), 217 bytes | 217.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To https://github.com/geminiyu233/test1.git
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'
```

把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。

由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令`git push`。

推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：
![远程仓库内容](2.jpg)

## 2.3 从远程库克隆

上面我们讲了先有本地库，后有远程库的时候，如何关联远程库。

现在，假设我们从远程库克隆。直接使用命令git clone克隆一个本地库：

```js
git remote add origin https://github.com/geminiyu233/test1.git
Cloning into 'test1'...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3
Receiving objects: 100% (3/3), done.
```

# 3 时光穿梭机

我们已经成功地添加并提交了一个README.md文件，现在，是时候继续工作了，于是，我们继续修改README.md文件

现在，运行git status命令看看结果：

```js
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

`git status`命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，`README.md`被修改过了，但还没有准备提交的修改。

虽然Git告诉我们`README.md`被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的`README.md`，所以，需要用`git diff`这个命令看看：

![修改明细](3.jpg)

## 3.1 工作区和暂存区

在讲下面内容前，我们先了解概念工作区和暂存区

- 工作区（Working Directory）

就是你在电脑里能看到的目录，比如我的`test1`文件夹就是一个工作区：

![工作区](4.jpg)

- 版本库（Repository）
工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。

Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。

![版本库](5.jpeg)

## 3.2 版本回退

在我们反复不断对一个文件进行了修改，然后不断对提交修改到版本库中，现在我们来回顾下我们README.md文件一共有几个版本被提交到Git仓库中了：

版本1：

```js
我是女
我是女生
```

版本2：

```js
我是女生
我是漂亮女生
```

版本3：

```js
我是漂亮女生
我是贼漂亮女生
```

当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：

```js
git log
```

git log命令显示从最近到最远的提交日志，我们可以看到3次提交

如果嫌输出信息太多，看得眼花缭乱的，可以试试加上`--pretty=oneline`参数：

```js
git log --pretty=oneline
```

好了，现在我们启动时光穿梭机，准备把`README.md`回退到上一个版本，也就是`add distributed`的那个版本，怎么做呢？

现在，我们要把当前版本append GPL回退到上一个版本`add distributed`，就可以使用git reset命令：

```js
$ git reset --hard HEAD^
HEAD is now at e475afc add distributed
```

还可以继续回退到上一个版本，不过且慢，让我们用git log再看看现在版本库的状态：

```js
git log
```

最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？

办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：

```js
$ git reset --hard 1094a
HEAD is now at 83b0afe append GPL
```

Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：

然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。

版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。

现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？

在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：

```js
$ git reflog
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -> master) HEAD@{2}: commit: append GPL
e475afc HEAD@{3}: commit: add distributed
eaadf4e HEAD@{4}: commit (initial): wrote a readme file
```

终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。

## 3.3 撤销修改

- 假设你正在开发一个功能，在你准备提交前，突然想起某段代码写错了，这个时候你可以删除最后一行，手动恢复到上一个版本状态。如果用`git status`查看一下：

```js
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

你可以发现，Git会告诉你，`git restore file`可以丢弃工作区的修改：

```js
git restore README.md
```

命令git restore README.md意思就是，把README.md文件在工作区的修改全部撤销，这里有两种情况：

一种是README.md自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；

一种是README.md已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。

总之，就是让这个文件回到最近一次git commit或git add时的状态。

- 假设你不但写了一些bug，还git add到暂存区了。庆幸的是，在commit之前，你发现了这个问题。用`git status`查看一下，修改只是添加到了暂存区，还没有提交：

```js
git status              
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   README.md
```

Git同样告诉我们，用命令`git restore --staged <file>`可以把暂存区的修改撤销掉（unstage），重新放回工作区：

```js
git restore --staged README.md
```

再用`git status`查看一下，现在暂存区是干净的，工作区有修改：

```js
$ git status                    
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

# 4 分支管理

假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。

现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。

## 4.1 创建与合并分支

在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。

一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：

![master](6.png)

每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。

当我们创建新的分支，例如dev时，Git新建了一个指针（分支）叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：

![master](7.png)

Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！

不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：

![master](8.png)

假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：

![master](9.png)

所以Git合并分支也很快！就改改指针，工作区内容也不变！

合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：

![master](10.png)

下面开始实战。

```js
$ git checkout -b dev
Switched to a new branch 'dev'
```

`git checkout`命令加上-b参数表示创建并切换，相当于以下两条命令：

```js
$ git branch dev
$ git checkout dev
Switched to branch 'dev'
```

然后，用git branch命令查看当前分支：

```js
$ git branch
* dev
  master
```

`git branch`命令会列出所有分支，当前分支前面会标一个*号。

然后，我们就可以在dev分支上正常提交。现在，dev分支的工作完成，我们就可以切换回master分支：

```js
$ git checkout master
Switched to branch 'master'
```

切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：

![master](11.png)

现在，我们把dev分支的工作成果合并到master分支上：

```js
$ git merge dev
Updating 07220b9..4a65a7c
Fast-forward
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
```

git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。

合并完成后，就可以放心地删除dev分支了：

```js
$ git branch -d dev
Deleted branch dev (was 4a65a7c).
```

删除后，查看branch，就只剩下master分支了：

```js
$ git branch
* master
```

## 4.2 解决冲突

合并分支往往也不是一帆风顺的，现在我们模拟一个冲突的情况：

准备新的`feature1`分支，在该分支上修改一行代码；然后`git add`，`git commit`
切换到`master`分支，在同一行修改代码；然后`git add`，`git commit`
现在，master分支和feature1分支各自都分别有新的提交，变成了这样：

![master](12.png)

这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：

```js
$git merge dev
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit the result.
```

果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。`git status`也可以告诉我们冲突的文件：

```js
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改后保存，在你准备提交：

```js
$ git add readme.txt 
$ git commit -m "conflict fixed"
[master cf810e4] conflict fixed
```

现在，master分支和feature1分支变成了下图所示：

![master](13.png)

用带参数的git log也可以看到分支的合并情况：

```js
$ git log --graph --pretty=oneline --abbrev-commit
*   2abc8c6 (HEAD -> dev) conflict fixed
|\  
| * c7f0aef (master) feat: e
* | a3d5813 feat: test
|/  
* a3afc7d feat: test
* 461746a feat: test
* 4a65a7c feat: test
* 07220b9 (origin/master) init
```

## 4.3 多人协作

多人协作时，大家都会往master和dev分支上推送各自的修改。

当你从远程库clone时，默认情况下，你只能看到本地的master分支。不信可以用git branch命令看看：

```js
$ git branch
* master
```

现在，你要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是用这个命令创建本地dev分支：

```js
git checkout -b dev origin/dev
```

现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：

```js
$ git add env.txt

$ git commit -m "add env"
[dev 7a5e5dd] add env
 1 file changed, 1 insertion(+)
 create mode 100644 env.txt

$ git push origin dev
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
   f52c633..7a5e5dd  dev -> dev
```

你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：

```js
$ git push origin dev
To github.com:michaelliao/learngit.git
 ! [rejected]        dev -> dev (non-fast-forward)
error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：

```js
$ git pull
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/<branch> dev
```

git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：

```js
$ git branch --set-upstream-to=origin/dev dev
Branch 'dev' set up to track remote branch 'dev' from 'origin'.
```

再pull：

```js
$ git pull
Auto-merging env.txt
CONFLICT (add/add): Merge conflict in env.txt
Automatic merge failed; fix conflicts and then commit the result.
```

这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：

```js
$ git commit -m "fix env conflict"
[dev 57c53ab] fix env conflict

$ git push origin dev
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.
Total 6 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
   7a5e5dd..57c53ab  dev -> dev
```

## 4.4 强迫症-变基 Rebase
