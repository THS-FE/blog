---

title: git使用
author: 喻双
authorLink: <https://github.com/geminiyu233>
excerpt: 本文主要讲解了关于 git使用 的相关知识。
cover: 2022/08/04/git使用/cover.jpg
thumbnail: 2022/08/04/git使用/cover.jpg
categories:

- - JavaScript
- 工具使用

tags:

- JavaScript
toc: true
date: 2021-08-04 17:34:26

---

# 1 前言

读完全文，希望你能明白：

- [什么是git](https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000)
- [集中式VS分布式：Git VS SVN](<https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248>)
- git常用使用场景及使用方法

# 2 本地/远程仓库

## 2.1 创建版本库

>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。

1. 本地创建一个文件夹
2. 把这个目录变成Git可以管理的仓库

```js
$ git init
Initialized empty Git repository in /Users/yushuang/Documents/技术分享/test1/.git/
```

瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的人可以发现当前目录下多了一个.git的目录，这个目录是Git用来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。

如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见

```js
git add file1.txt
git add file2.txt file3.txt
git commit -m "add 3 files." 
```

## 2.2 添加远程库

> 通过以上操作，现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。

我们在Github上创建一个仓库，成功后会看到以下截图
![Github成功创建仓库](1.png)

现在，我们根据GitHub的提示，在本地的`test1`仓库下运行命令：

```js
git remote add origin https://github.com/geminiyu233/test1.git
```

添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。

下一步，就可以把本地库的所有内容推送到远程库上：

```js
$ git push -u origin master
Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Writing objects: 100% (3/3), 217 bytes | 217.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To https://github.com/geminiyu233/test1.git
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'
```

把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。

由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令`git push`。

推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：
![远程仓库内容](2.jpg)

## 2.3 从远程库克隆

上面我们讲了先有本地库，后有远程库的时候，如何关联远程库。

现在，假设我们从远程库克隆。直接使用命令git clone克隆一个本地库：

```js
git remote add origin https://github.com/geminiyu233/test1.git
Cloning into 'test1'...
remote: Counting objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3
Receiving objects: 100% (3/3), done.
```

# 3 时光穿梭机

我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件

现在，运行git status命令看看结果：

```js
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```

`git status`命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，`readme.txt`被修改过了，但还没有准备提交的修改。

虽然Git告诉我们`readme.txt`被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的`readme.txt`，所以，需要用`git diff`这个命令看看：

![修改明细](3.jpg)

## 3.1 工作区和暂存区

在讲下面内容前，我们先了解概念工作区和暂存区

## 3.2 版本回退

在我们反复不断对一个文件进行了修改，然后不断对提交修改到版本库中，现在我们来回顾下我们README.md文件一共有几个版本被提交到Git仓库中了：

版本1：

```js
我是女
我是女生
```

版本2：

```js
我是女生
我是漂亮女生
```

版本3：

```js
我是漂亮女生
我是贼漂亮女生
```

当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：

```js
git log
```

git log命令显示从最近到最远的提交日志，我们可以看到3次提交

如果嫌输出信息太多，看得眼花缭乱的，可以试试加上`--pretty=oneline`参数：

```js
git log --pretty=oneline
```

好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？

现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：

```js
$ git reset --hard HEAD^
HEAD is now at e475afc add distributed
```

还可以继续回退到上一个版本，不过且慢，让我们用git log再看看现在版本库的状态：

```js
git log
```

最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？

办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：

```js
$ git reset --hard 1094a
HEAD is now at 83b0afe append GPL
```

Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：

然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。

版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。

现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？

在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：

```js
$ git reflog
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -> master) HEAD@{2}: commit: append GPL
e475afc HEAD@{3}: commit: add distributed
eaadf4e HEAD@{4}: commit (initial): wrote a readme file
```

终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。

## 3.3 管理修改

## 3.4 撤销修改

## 3.5 删除文件

# 4 分支管理

## 4.1 创建与合并分支

## 4.2 解决冲突

## 4.3 多人协作

## 4.4 强迫症-变基 Rebase

## 5 标签管理

## 5.1 创建标签

## 5.2 操作标签

# 6 忽略特殊文件
